function heldKarp(cities) {
    n = cities.length
    // Initialize memoization table
    // memo[S][i] = min cost of path ending at i and visiting all cities in S
    memo = new table[2^n][n] filled with -1 (to indicate uncomputed)

    // Start recursive call from city 0
    return HK(cities, {0}, 0, memo);
}

function HK(cities, S, i, memo) {
    // If we've already computed this subproblem, return the result
    if (memo[S][i] != -1) return memo[S][i]

    // If all cities have been visited, do nothing

    // Initialize with infinity
    minCost = infinity

    // Try to visit each unvisited city
    for each city j not in S:
        // Create new set with j added
        S' = S 
}